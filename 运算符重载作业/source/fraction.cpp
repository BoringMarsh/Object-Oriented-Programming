#include<iostream>
#include<cmath>
#include"fraction.h"
using namespace std;

/***************************************************************************
  函数名称：Inverse
  功    能：取负运算
  输入参数：无
  返 回 值：无
  说    明：该函数仅改变分子的正负性
***************************************************************************/
void fraction::Inverse()
{
	n = -n;
}

/***************************************************************************
  函数名称：Reciprocal
  功    能：求倒数
  输入参数：无
  返 回 值：无
  说    明：该函数交换了分子和分母的值
***************************************************************************/
void fraction::Reciprocal()
{
	long long mid = n;
	n = d;
	d = mid;
}

/***************************************************************************
  函数名称：gcd
  功    能：求两个数的最大公因数
  输入参数：const long long a：第一个数（只读）
            const long long b：第二个数（只读）
  返 回 值：long long：两数的最大公因数
  说    明：求解方法为欧几里得辗转相除法
***************************************************************************/
long long gcd(const long long a, const long long b)
{
	long long c = a > b ? a : b;
	long long d = a < b ? a : b;

	while (c % d != 0) {
		long long e = c % d;
		c = d, d = e;
		gcd(c, d);
	}

	return d;
}

/***************************************************************************
  函数名称：Reduction
  功    能：约分
  输入参数：无
  返 回 值：无
  说    明：无
***************************************************************************/
void fraction::Reduction()
{
	if (n == 1 || n == 0 || d == 1 || d == 0)  /*若分子、分母为1或0，不进行任何操作*/
		return;

	if (n < 0 && d < 0)  /*若分子分母均为负，则约掉-1*/
		n = -n, d = -d;

	else {  /*一般情况，分子分母除去最大公因数*/
		const long long g = gcd(long long(fabs(n)), long long(fabs(d)));
		n = n / g;
		d = d / g;
	}
}

/***************************************************************************
  函数名称：DtoF
  功    能：输入是double型转成分数
  输入参数：double num：输入的数（只读）
  返 回 值：无
  说    明：无
***************************************************************************/
void fraction::DtoF(const double num)
{
	long long D = 1;
	double N = num;

	while (fabs(N - long long(N)) >= 10e-12) {  /*每次循环分子分母同乘10，直到分子小数部分为零*/
		N = N * 10;
		D = D * 10;
	}

	n = long long(N), d = D;  /*将所得值赋给自身分子分母*/
	Reduction();  /*进行约分*/
}

/***************************************************************************
  函数名称：StoF
  功    能：输入是字符串型分数的表示转成数值型分数
  输入参数：const char* String：输入的字符串（只读）
  返 回 值：无
  说    明：该函数支持分子分母各自带负号的输入情况
***************************************************************************/
void fraction::StoF(const char* String)
{
	n = 0, d = 0;  /*将当前分子分母归零，以免对后续造成干扰*/
	bool if_minus[2] = { false,false };
	const char* p = String;  /*指针p指向String首地址*/

	if (*p == '-') {  /*若分子有负号，则标记为真*/
		if_minus[0] = true;
		p++;
	}

	while (*p != '/' && *p != '\0') {  /*读分子*/
		if (*p >= '0' && *p <= '9') {
			n = n * 10 + *p - '0';
			p++;
		}
	}

	if (*p == '/')  /*读除号*/
		p++;

	if (*p == '-') {  /*若分母有负号，则标记为真*/
		if_minus[1] = true;
		p++;
	}

	while (*p != '\0') {  /*读分母*/
		d = d * 10 + *p - '0';
		p++;
	}

	if (if_minus[0])  /*分子标记为真，取相反数*/
		n = -n;
	if (if_minus[1])  /*分母标记为真，取相反数*/
		d = -d;

	Reduction();  /*进行约分*/
}

/***************************************************************************
  函数名称：operator+
  功    能：进行分数的加法
  输入参数：const fraction& f：加数（只读）
  返 回 值：fraction：加法所得结果
  说    明：本函数在计算结果后同时进行了约分
***************************************************************************/
fraction fraction::operator+(const fraction& f)
{
	fraction ret;
	ret.n = n * f.d + d * f.n;
	ret.d = d * f.d;
	ret.Reduction();
	return ret;
}

/***************************************************************************
  函数名称：operator-
  功    能：进行分数的减法
  输入参数：const fraction& f：减数（只读）
  返 回 值：fraction：减法所得结果
  说    明：本函数在计算结果后同时进行了约分
***************************************************************************/
fraction fraction::operator-(const fraction& f)
{
	fraction ret;
	ret.n = n * f.d - d * f.n;
	ret.d = d * f.d;
	ret.Reduction();
	return ret;
}

/***************************************************************************
  函数名称：operator*
  功    能：进行分数的乘法
  输入参数：const fraction& f：乘数（只读）
  返 回 值：fraction：乘法所得结果
  说    明：本函数在计算结果后同时进行了约分
***************************************************************************/
fraction fraction::operator*(const fraction& f)
{
	fraction ret;
	ret.n = n * f.n;
	ret.d = d * f.d;
	ret.Reduction();
	return ret;
}

/***************************************************************************
  函数名称：operator/
  功    能：进行分数的除法
  输入参数：const fraction& f：除数（只读）
  返 回 值：fraction：除法所得结果
  说    明：本函数在计算结果后同时进行了约分
***************************************************************************/
fraction fraction::operator/(const fraction& f)
{
	fraction ret;
	ret.n = n * f.d;
	ret.d = d * f.n;
	ret.Reduction();
	return ret;
}

/***************************************************************************
  函数名称：operator%
  功    能：进行通分
  输入参数：const fraction& f：另一个数（只读）
  返 回 值：无
  说    明：该函数将自身和作为参数的对象这两个数进行通分
***************************************************************************/
void fraction::operator%(fraction& f)
{
	const long long g = gcd(d, f.d);
	const long long t = d * f.d / g;
	n = n * (t / d);
	d = d * (t / d);
	f.n = f.n * (t / f.d);
	f.d = f.d * (t / f.d);
}

/***************************************************************************
  函数名称：operator>
  功    能：判断大于
  输入参数：const fraction& f：参与比较的数（只读）
  返 回 值：bool：是否大于
  说    明：无
***************************************************************************/
bool fraction::operator>(const fraction& f)
{
	if (n * f.d - d * f.n > 0)
		return true;
	else
		return false;
}

/***************************************************************************
  函数名称：operator<
  功    能：判断小于
  输入参数：const fraction& f：参与比较的数（只读）
  返 回 值：bool：是否小于
  说    明：无
***************************************************************************/
bool fraction::operator<(const fraction& f)
{
	if (n * f.d - d * f.n < 0)
		return true;
	else
		return false;
}

/***************************************************************************
  函数名称：operator>=
  功    能：判断大于等于
  输入参数：const fraction& f：参与比较的数（只读）
  返 回 值：bool：是否大于等于
  说    明：无
***************************************************************************/
bool fraction::operator>=(const fraction& f)
{
	if (n * f.d - d * f.n >= 0)
		return true;
	else
		return false;
}

/***************************************************************************
  函数名称：operator<=
  功    能：判断小于等于
  输入参数：const fraction& f：参与比较的数（只读）
  返 回 值：bool：是否小于等于
  说    明：无
***************************************************************************/
bool fraction::operator<=(const fraction& f)
{
	if (n * f.d - d * f.n <= 0)
		return true;
	else
		return false;
}

/***************************************************************************
  函数名称：operator==
  功    能：判断等于
  输入参数：const fraction& f：参与比较的数（只读）
  返 回 值：bool：是否等于
  说    明：无
***************************************************************************/
bool fraction::operator==(const fraction& f)
{
	if (n * f.d - d * f.n == 0)
		return true;
	else
		return false;
}

/***************************************************************************
  函数名称：operator!=
  功    能：判断不等于
  输入参数：const fraction& f：参与比较的数（只读）
  返 回 值：bool：是否不等于
  说    明：无
***************************************************************************/
bool fraction::operator!=(const fraction& f)
{
	if (n * f.d - d * f.n != 0)
		return true;
	else
		return false;
}

/***************************************************************************
  函数名称：display
  功    能：显示函数
  输入参数：无
  返 回 值：无
  说    明：该函数按照要求调整了输出顺序
***************************************************************************/
void fraction::display()
{
	if (d == 0) {  /*当分母是0时的输出*/
		cout << "输出不能为零" << endl;
		return;
	}
	
	if (n == 0) {  /*当分子为零输出0*/
		cout << 0 << endl;
		return;
	}

	if (n * d < 0)  /*当分子分母异号的时候输出负号*/
		cout << '-';

	const long long N = long long(fabs(n));  /*取分子绝对值*/
	const long long D = long long(fabs(d));  /*取分母绝对值*/

	if (D != 1)  /*若分母绝对值不为1，输出分子分母；若分母绝对值为1，仅输出分子*/
		cout << N << '/' << D << endl;
	else
		cout << N << endl;
}